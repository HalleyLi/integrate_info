

#  微服务和SOA服务

@(综合)


**微服务架构**就服务类型而言其分类法并不复杂，一般来说主要有**两类服务类型**，如图2-1所示。**功能服务**（functional services）是指用来支持特定业务操作或功能的服务，而**基础服务**（infrastructure services）则负责支持非业务工作，例如认证、授权、审计、日志和监控。在微服务架构中，这是非常重要的区别，因为基础服务并不对外开放而仅作为供内部使用的私有共享服务，对其它服务可用。功能服务则提供外部访问能力，而且不对其它服务共享。

![Alt text](./1474879017780.png)


**SOA**内的服务分类法跟微服务有很大不同。在SOA中，从全局架构来看有非常明确的、非常正式的服务类型，各自在整体架构中扮演不同角色。**尽管在SOA中可以有任意数量的服务类型**，**架构模式定义了四种基本类型**，如图2-2所示：

![Alt text](./1474879061641.png)

业务服务（business services）是一种抽象的、高层级的、粗粒度的服务，定义在企业层面的执行的核心业务操作。因为抽象，所以不依赖于任何实现或者协议，一般只包括服务名字，期望的输入以及期望的输出。可选地，这些服务类型还可以包括处理步骤或者跟服务相关的特殊编排规则。**业务服务一般都用XML、Web Services Definition Language（WSDL）或者Business Process Execution Language（BPEL）等语言来表述**。一般确认某个服务是否属于业务服务会在服务名上下文前后加上“我们是否在做某某的业务”来加以判断。例如，有两个服务，分别名为ProcessTrade（处理交易）和InsertCustomer（插入客户）。那么“我们是否在做处理交易的业务”可以很清楚看出ProcessTrade是一个业务服务；而“我们是否在处理插入客户的业务”听上去就不对，所以不是一个好的业务服务抽象，更像是一个在处理业务服务时所调用的某个具体服务。

**企业服务**（enterprise services）是具体的、企业层级的、粗粒度的服务，用以实现业务服务所定义的功能。如图2-2中所示，一般是介于抽象业务服务和对应具体企业服务实现之间的中间件，在其间起到桥梁作用。企业服务可以与业务服务之间存在一对一或一对多的对应关系。**企业服务很独特的一点是它们通常会在组织内共享**

**应用服务**（application services）是细粒度的、特定于具体应用的服务，与某个特定应用的语境相关。应用服务提供在企业服务中没有的特定的业务功能。例如，一个大型保险公司汽车报价应用可能提供服务来计算汽车保险费率。这是一个只针对该应用而并不适用于整个企业的服务。应用服务可以从某个专用的用户界面直接调用，或者通过某个企业服务调用。应用服务的例子包括：AddDriver（添加司机）、AddVehicle（添加车辆）以及CalculateAutoQuote（计算机车报价）等等。

需要记住的是，**作为一个架构师，你既可以使用架构模式所提供的标准服务类型，也可以完全抛弃他们创建自己的分类方式。不管采用哪种方式，重要的事情是要确保针对架构存在定义良好且文档齐备的服务分类法**。

### 服务责任制与协调

服务责任人（service owner）是组织内负责创建和维护某个服务的组别的类型。因为微服务架构仅支持有限的服务类型（功能服务和基础服务），应用开发团队一般都会同时负责这两种服务。尽管大量应用开发团队可能负责编写服务，需要了解的是他们都属于同一组别类型（即应用开发团队）

对于SOA而言，一般对不同服务类型有不同服务责任人。业务服务的责任人通常是业务用户，而企业服务的责任人大多是是共享的服务团队或者架构师。应用服务的责任人一般是应用开发团队，基础服务的责任人一般是应用开发团队或者基础服务团队。中间件在SOA架构中经常使用，尽管不是一种服务，其责任人一般是整合架构师或者中间件团队

![Alt text](./1474879617031.png)


服务责任人的重要性体现在全局的服务协调。在SOA中，必须在创建或维护某个应用需求的时候在多个组之间进行协调。关于抽象的业务服务必须咨询业务用户，关于完成业务服务功能所需的企业服务必须咨询共享服务团队，应用开发团队之间必须相互协调才能保证企业服务可以调用底层功能。同样，必须协调基础团队来确保非功能性需求能够通过基础服务得到保障。最后，所有这些都需要与中间件团队或者管理消息中间件的整合架构师进行协调。

### 服务粒度

微服务架构中的服务组件一般都是单一目的/用途的服务，只做一件事且做到极致。

对于SOA而言，服务组件规模相差可以很大，可能是很小的应用服务，也可以是很大的企业服务

**架构师和组件设计师很快学习到大规模的、粗粒度的、提供多种数据视图的服务是更好的服务模式**

**服务粒度既影响性能也影响事务管理。服务的粒度太细时需要服务间通信来完成单一业务请求，从而导致大量的远程服务请求，占用掉宝贵的时间。**

在处理服务粒度时，我发现从粗粒度服务开始会更容易一些。随着对服务的用法的了解逐渐增加，不妨再考虑如何对其进行拆分。如Sam Newman在《Building Microservices》（http://shop.oreilly.com/product/0636920033158.do）书中所说，“从少数几个大服务开始”。只需要观察事务问题和服务之间通信量，尤其是在微服务架构下，如果发生相关问题很可能说明服务可能粒度太细了。

## 粒度与模式选择

服务粒度在根据情况进行架构模式选择的过程中具有最重要的潜在影响。微服务中规模很小的、细粒度的服务概念使得这种架构模式能够提升软件开发生命周期中的各个方面，包括开发、测试、部署和维护。尽管采用粗粒度服务肯定会解决性能和事务问题，这一转变反过来肯定也会给开发、测试、部署和维护带来负面影响。如果发现服务规模从小变大，那么最好选择SOA模式而不是更为简单的微服务架构模式。不过，如果能够将应用的业务功能分解为很小的、互相独立的部分，微服务模式应该是更好的选择。

### 比较架构特性

组件（component）是软件中的一个单位，具有定义良好的接口、定义良好的角色/责任集合。组件是架构的构成元素。对于基于服务的架构，这些构成元素通常被称为服务（或者服务组件）。不管组件带上什么标签，**当创建一个架构时，你都需要决定组件如何被共享、组件间如何通信、多个组件如何被整合起来完成业务请求以及如何从远程服务用户的位置访问他们**。

为这些问题做出决定并不是件容易的事情，这就是为什么需要了解架构模式的原因。每种架构模式都有独特的拓扑结构用来定义架构的形状和一般属性，包括组件之间如何相互关联、如何通信、如何协作完成业务请求等等。通过分析**架构模式的拓扑结构**，你可以更好地决定哪种模式更适合你要开发的应用。

### 组件共享

在组件共享方面，微服务与SOA是有本质上的差异的。SOA是建立在“能共享就共享（share-as-much-as-possible）”的架构风格之上的，而微服务是建立在“能不共享就不共享（share-as-little-as-possible）”的架构风格之上

尽管“能共享就共享”的架构解决了与业务功能重复相关的问题，但是却带来了组件间耦合过于紧密的问题，增加了与变更相关的整体风险。例如，假设对图3-2中的Order服务做了某个变更，因为Order服务是一个企业服务，对全公司范围可见，很难测试该服务的全部使用场景以确保这次变更不会影响到企业其他部门。

微服务架构，是基于“能不共享就不共享”的理念的，利用了一个领域驱动设计中的概念限定语境（bounded context）。架构上来看，限定语境是指组件（或者这里的服务）与其所关联的数据紧密耦合成一个封闭的单元，与外界有着最小的依赖。这种方式设计的服务组件本质上都是自包含的，只开放定义良好的接口和定义良好的合约。

切合实际地说，即使在微服务架构中也总有某些服务（例如，基础服务）是共享的。然而，SOA架构总是倾向于更大化组件共享，而微服务架构则通过限定语境的概念最小化共享

### 服务调配（orchestration）与编排（choreography）

服务调配指的是多个服务通过一个集中式调节者进行协调。这里的调节者可以是服务的客户，也可以是一个集成枢纽（Mule、Camel、Spring Integration等）

服务编排指的则是没有中央协调者的情况下多个服务调用之间的协调

**微服务架构更适合采用服务编排而不是服务调配，主要是因为这种架构的拓扑结构中没有一个集中式的中间件组件**。图3-5所展示的全局架构拓扑中包含两类主要组件：服务组件和（是可选的）非智能化的API层。（我会在下一节讨论API层及其扮演的角色）。从实现的角度来看，架构中还可以有其他组件，例如服务注册和发现组件、服务监控组件和服务部署管理器等等，但是就微服务结构模式的服务分类法而言，它们更应该被视作基础服务。

![Alt text](./1474880874053.png)


微服务架构是一种“能不共享就不共享”的架构，你应该尽量减少服务编排的数量，尽可能让功能服务与基础服务进行交互。如前一章所述，如果发现在功能服务之间需要进行大量的服务编排工作，很有可能是因为你的服务粒度太细了

在**微服务架构中执行太多的服务编排可能会导致出耦合度（efferent coupling）太高的问题**。出耦合度这个术语指的是某个组件为了完成某个业务请求在多大程度上需要依赖其它组件。考虑图3-6中的例子，展示了处理订单请求时所需要的三个服务：validate order（验证订单），place order（下单）和notify customer（通知客户）。架构上来说，这个业务请求有很高的出耦合度，而这正是架构师们在采用大多数微服务架构中尽量避免的。

![Alt text](./1474880996435.png)


**服务编排中中发生的服务耦合问题可能引起性能不佳以及应用不稳定的问题**。正如前一章所讨论的，因为微服务架构下的服务一般都是远程服务，使用服务编排进行服务协调时所产生的每个服务调用都会延长请求的响应时间，因为远程访问协议的通信传输时间总是存在的。另外，**为同一业务请求而对多个服务进行协调时，调用链上的任何一个服务都可能出现不可用或者不响应的状况，从而会导致应用可靠性和稳定性都会下降**。

为解决微服务架构中对多个功能服务进行编排的问题，可以考虑将多个细粒度服务合并成一个粗粒度服务

图3-7中展示的是如何通过将三个细粒度服务整合为一个粗粒度服务，消除服务编排从而解决与服务编排相关的问题。这里所指的问题具体包括：首先，因为减少了远程调用，整体的性能会得到提升；第二，因为服务可用性的问题出现得更少，整体的稳定性得以改进；最后，因为不再需要远程服务合约，总体上的部署和维护得以简化。

![Alt text](./1474881098148.png)

SOA，作为一种“能共享就共享”的架构，同时依靠服务调配和编排来完成业务请求的处理。如图3-8所示，SOA中的消息中间件，通过调用多个企业服务来处理同一业务服务请求，从而完成服务调配。一旦加入到企业服务中，服务编制组件可以用于调用应用服务或者基础服务来帮助完成特定业务请求。

![Alt text](./1474881164442.png)


### 中间件与API层

**微服务模式不支持消息中间件**（例如，集成枢纽或者企业服务总线）的概念，而是支持在所有服务的前端设置一个API层作为服务接入层。**在客户和服务之间放置一个API层通常是个不错的主意，因为这个组件实质上构造了一个抽象层，使得客户不需要知道服务端的确切位置**。同时也使得服务粒度的改变不会影响到服务客户。对服务粒度进行抽象的确需要在API层提供一定的智能和一定程度的调配能力，但这些问题可以慢慢通过重构解决，重要的是服务端可以根据需要演化，而不是要求服务的客户也经常做出变更


**调解和路由（mediation and routing）**指的是架构基于特定业务或者用户请求来对服务进行定位和调用的能力。这种能力如图3-9所示。注意本图中对服务注册或服务发现组件的使用，以及对服务调配能力的利用。微服务和SOA都有这种能力，特别是服务注册或者服务发现模块所提供的能力。不过，服务调配在微服务中被严格控制甚至排除，而在SOA中却是经常用到的能力。

![Alt text](./1474881532897.png)


**消息增强（message enhancement）**指的是架构在请求的数据部分到达服务之前之前对其进行修改、删除或者增加的能力;消息增强的例子包括改变日期格式、添加额外数值或者查询数据库进行数据转换，例如将统一安全鉴定程序委员会（Committee on Uniform Security Identification Procedures，CUSIP）代码转换为股票代码或者从后者转换为前者。微服务模式不提供这种能力，主要是因为其架构中不包含实现这一功能的中间件组件。SOA通过其消息中间件完全支持这种能力。

![Alt text](./1474881678550.png)

**消息转换（message transformation）**指的是架构将一种数据格式转换为另外一种格式的能力;客户调用服务并以JSON格式发送数据，而服务期望接收的是Java对象。注意消息增强『译注：似应为消息转换』并不关心请求相关的数据本身，而只是关注数据格式的转换。微服务架构并不提供这种能力，而SOA架构则通过消息中间件提供这种功能。

![Alt text](./1474881722833.png)

**协议转换（protocol transformation）所描述的是架构允许客户采用与服务端预期不匹配的协议来调用服务的能力**。图3-12展示了这种能力。注意，图中服务客户采用REST进行通信，但是负责处理请求的服务要求建立RMI/IIOP链接（例如，Enterprise JavaBeans 3 [EJB3]）和AMQP连接。微服务可以支持多种协议类型，但是服务的客户和服务必须采用同一通信协议。在SOA架构中，多个协议则可以根据需要混合使用。

![Alt text](./1474881791490.png)


### 访问远程服务




