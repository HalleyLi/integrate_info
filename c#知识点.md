#### c# 知识点整理

@(综合)

1. 委托的Invoke方法用来进行同步调用，还有异步调用通过BeginInvoke和EndInvoke实现
2. 回调函数，当调用结束时会自动回调函数

    IAsyncResult result= handler.BeginInvoke(1,2,new AsyncCallback(AddComplete),"AsyncState:OK");

**const只能在初期就使用常量初始化好，对每一次编译后的结果，const的值是固定的**，而readonly的值是可以在运行的时候才确定值，并且readonly字段可以在生命或构造函数中初始化。

类的私有成员可以被子类继承，但是不能被访问。

var getName是**函数表达式**，而function getName 是**函数声明**

**this指向的问题是由所在函数的调用方式决定的**

加索引并不是越多越好，一定要是经常使用条件筛选的列，并且where中要避免对有索引的列进行计算，索引并不是越多越好，索引会占用更多的存储空间，也会对insert/update/delete这些操作有一定的影响。

视图是一种虚拟的表，虚拟表具有和物理表相同的功能，可以对虚拟表进行增改查操作；

存储过程，执行快，减少网络流量，更好的安全机制
select * from (select * ,ROW_NUMBER() OVER(ORDER BY ID) AS rownum FROM A) T WHERE T.rownum between 31 and 40

装箱：将值类型转换为引用类型
拆箱：将引用类型转换为值类型

传值方式：QueryString  response.Redirect() Server.transfer  Session Cookie 
override重写

**策略模式**
定义接口
多种类继承该接口
定义上下文传传入继承类
static main中 获取上下文，传入类，实现方法

**代理模式**
定义接口，man以及人中里的集中方法
定义潘基连继承该接口，并实现
定义王婆，默认构造函数为潘金莲，也继承该接口，实现方法都用潘金莲的方法

**单利模式**
publi emperor{
 private static final Emperor emperor=new Emperor();
 private Emperor(){}
public synchronized static Emperor getInstance(){
return emperor;
}
}

**门面模式**
定义写信的各种方法作为一个接口
写一个实现继承该接口
写一个类方法中有私有化的该实现类的实例，以及一个送信方法，传入上下文和地址，
送信方法中以确定好写信的顺序，调用时，调用该方法即可。


**程序集**是一个或多个模块和资源文件的集合。
1. 允许多编程语言开发
2. 允许逻辑分布和物理分布分离。


**应用程序域**一个CLR在运行时，将至少拥有一个应用程序域。一个或多个应用程序与在一个操作系统进程中运行。
.net程序会进行两次编译，第一次，形成CLR头/元数据和中间代码。在实施运行或者部署时，将经过第二次编译，编译的结果实在CLR中可执行的机器代码。

Load;loadFrom主动加载程序集。前者通过唯一标识强命名程序集的4个元素来标识程序集。后者通过位置。CLR的加载机制和load方法一直，其内在策略是依次通过版本策略/codebase位置/应用程序域位置和应用程序位置来查找程序集。

**版本策略**
1. 应用程序策略  可以在应用程序配置文件中配置/.config  bindingRedirect  oldversion  newversion
2. 发行者策略  
3. 计算机策略 machine.config

**如何生成强签名的程序集**
强签名：  带有公钥和数字签名的程序集，每个强签名都可以由四个元素来唯一标识，他们分别是：文件名/版本号/语言文化/公钥。
。net中公钥私钥机制属于非对称加密技术。特点试试加密方用公钥对信息加密，而揭密方需要使用公钥和预期配对的私钥进行解密。
在强签名程序集中，公钥和数字签名一起实现了对程序集的保护。
**如何生成强命名程序集**
1.  输入命令生成  sn -k C:/mypublickPrivateKey.snk
2.  输入  csc.exe /t:library Compile.cs  /keyfile:c:\MypublickPrivateKey.snk

GAC **应用程序集缓存**  只有带有工啊哟的强签名程序集才能被部署到GAC中去，
它有如下优点：
1. 程序集被多出引用是，可以有效减少内存成本
2. 通过发布者策略可以有效的发布程序集的最新版本
3. 同一程序集的多个版本可以共存，通过配置进行切换。

**延迟签名**把私钥加密延迟到项目真正发布时再进行。而在开发和测试阶段，程序员将只用一个公钥来生成强签名程序集。该带有公钥的程序集可以被放到GAC中，但要去除.net中对加密的认证。

**受托管的代码**：由公共语言运行库环境执行的代码

**类型初始化器** 不能被显示的调用，切只能有一个；
static  className(){}
任何一个静态成员变量先定义，然后再使用之前会调用类型初始化器
在使用时，首先应该考虑初始化表达式而不是自定义初始化器

**ref**要求参数在传入前被初始化
**out**要求参数在方法返回前被初始化
**params** 允许方法在定义时不确定参数的数量。局限是，如果有params参数，其后不允许有其他任何参数

**string和String是相同类型的两个名字，还有object和Object**

**深复制和浅复制**；他们的概念都是递归的（当引用类型成员中包含另外一个引用类型成员时，复制将对其内部成员实行同样的复制策略）
浅：复制原始对象中所有非静态值类型成员和所有的引用类型成员的引用。
深：复制原始对象中所有非静态值类型成员和所有的引用类型成员的实际对象

**using** 对于一些托管资源 .net可以通过GC进行回收释放，而非托管的需要手动释放。
两种主动和被动释放非托管资源的方式，即Idisposalbe接口的Dispose方法和类型自己的Finalize方法。但等待finalize释放会比较消耗资源，所以一般使用using；但要注意**千万不要试图在using语句块外面初始化对象**，比如对于多线程资源来说，如果初始化后突然产生医生一场，那么对象中的非托管资源就没有机会得到释放，这危害极大。
**c#编译器在编译时自动为using语句加上try/finally块，所以本质与一场捕捉语句一样**

**托管**代码中对象内存的分配和释放是由.net内存管理和GC统一管理的。
垃圾回收的运行成本较高，对与性能影响较大。所以应尽量避免呢村分配。

GC机制按照对象不被使用的可能性把托管堆里的对象分为3代。（0，1，2），越小的代拥有越多被释放的机会。

**内存泄露**是指内存空间上产生不再被实际使用，却又不能被实际分配的内存，
在。net托管堆上可能出现严重的内存泄露现象，原因有大对象的频繁分配和释放，不恰当的保留根引用和错误的finalize方法

**重写**通过override关键字重新实现基类中的虚方法，
**隐藏**是指用.NEW关键字重新实现基类中的方法，在运行的过程中通过引用的类型来判断应该调用哪个类型的方法。

尽量对异常可能出现的各种情况进行设计和捕捉，最后都需要对异常的基类Exception进行捕捉，这样才能保证所有的异常都不会被随意的抛出。

用**is和as**语句代替强制类型转换，可以有效避免InvalidCastException异常，执行效率相对较高。读者应该使用is和as语句来代替直接使用强制转换


**静态变量**
1. 存在于整个生命周期内
2. 在作用域外不可使用
3. 存放在程序的全局存储区

**c#可以对内存进行直接的操作，通过指针**；但为了保持类型安全，c#不支持指针运算。

**.net错误处理机制，四种**
**Page_Error**事件捕获在页面级出现的错误的方法。
**ErrorPage属性**每个页面都可以设置ErrorPage属性，从而确定页面发生错误的时候会重定向至哪个页面。注意web.config中的<customErrors>配置项中的mode属性必须设为“on”
**Application_Error**事件，捕获发生在应用程序中的错误。
**customErrors on**

**面向对象语言特性：**封装，继承，多态

**所有的数组类型继承于System.Array**,引用类型

1. 包含值类型项目的数组不能被隐式转换为其他任何类型
2. 能转换的前提是两者维数相同

数组类型可以通过Array.ConvertAll方法进行内容转换，该方法需要使用者提供一个转换算法，以委托或者方法的形式传入Array.ConvertAll方法中。

**泛型**开放式类型的泛型参数类型在被指定之前，不会被实例化成任何对象。
每个泛型参数可以有至多有一个主要约束，泛型的主要约束是指指定泛型参数必须或继承自某个引用类型，有两个特殊的主要约束：class  struct.

**流是一种对字节流的直接操作**，常见的流类型有文件流/终端操作流，网络socket等
**system.IO.Stream** 类型是所有流类型的虚基类，
流是对字节集合对象的一种操作

**序列化技术**可以把现有的实例化对象转换为方便传输的字节流
.net内建类型提供了三个可执行序列化和反序列化操作的类型：BinaryFormatter,SoapFormatter,XmlSerializer.

**实现ISerializable**

**如何把一个数组复制到ArrayList中？**
1.  foreach
2.  Array.ConvertAll














































































































